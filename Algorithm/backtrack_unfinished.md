## 回溯法
回溯法的思想是：**能进则进，进不了换，换不了退**。
**隐约束**指对能否得到问题的可行解和最优解做出的约束。隐约束包括**约束函数**和**限界函数**。
关键步骤是：
1. 定义解空间；
2. 确定解空间的组织结构（子集树、排列数、m叉树等）；
3. 搜索解空间。

回溯法阶梯的关键是设计有效的**显约束**和**隐约束**。

## 大卖场购物（0-1背包问题）

### 问题举例

每个物品重量w和价值v如下表所示，购物车容量为W，求不超过购物车重量的最大价值。

|w[]|1|2|3|4
| ------ | ------ | ------ | ------| ------|
||2|5|4|2 

|w[]|1|2|3|4
| ------ | ------ | ------ | ------| ------|
||6|3|5|4 

### 问题分析
1. 解空间={x<sub>1</sub>,x<sub>2</sub>,...,x<sub>i</sub>,...,x<sub>n</sub>}的所有子集（包括{0,0,0}这种子集），你像这里面就是{0,0,0,0},{0,0,0,1},{0,0,1,0},{0,0,1,1},…{1,1,1,1}。**显约束**为x<sub>i</sub>=0或1。
2. 确定解空间的组织结构。由于显约束的缘故，可以看出解空间为子集树。
3. 搜索解空间
- 约束条件为：w<sub>i</sub>x<sub>i</sub>≤W（i=1~n）
- 限界条件：cp+rp>bestp（cp为当前已经装入购物车的物品的总价值，rp为第t+1~第n种物品的总价值，bestp为最大价值）
4. 搜索过程见问题求解。

### 问题求解
（1）首先初始化。w[]={2,5,4,2}，v[]={6,3,5,4}，sumw=2+5+4+2=13，sumv=6+3+5+4=18，因为**sumw>W**，所以不能装完，所以需要进行后续的操作。此时定义一个cp=rp=bestp=0，x[i]=0，cw=0。
**<font color='red'>注意：在这里w[]和v[]的下标都是从1开始。并且以左子树为x<sub>i</sub>=1，右子树x<sub>i</sub>=0。</font>**


（2）开始搜索第一层（t=1）。cw=cw+w[1]=2<W，所以令x[1]=1，
cp=cp+v[1]=6，将2号结点加入**左子树**。(2号结点是第一个商品）

（3）拓展2号结点。考虑cw+w[2]=7<W，所以令x[2]=1，cp=cp+v[2]=9，将3号结点加入**左子树**。（3号结点是第2个商品）

（4）拓展3号结点。考虑cw+w[3]=11>W，所以x[3]=0，然后计算cp+rp=9+4=13>bestp（此时bestp还是0），所以将4号结点加入**右子树**。（4号结点是第3个商品）

（5）拓展4号结点。考虑cw+w[4]=9<W，所以x[4]=1，然后计算cp=cp+v[4]=13，所以将5号结点加入**左子树**。（5号结点是第4个商品）

（6）拓展5号结点。由于此时t>n，故已经找到了一个当前的最优解，令bestp=cp（值为13），5号结点成为死结点。返回到上一结点。

（7）**回溯**拓展4号。此时cp=9，若将5号结点加入右子树，cp+rp=9<bestp，故该结点不满足限界条件，成为死结点，继续回溯到3号结点。**由于3号结点已经研究过，左子树不可行，所以回溯到2号结点。**

（8）扩展2号结点（t=2）。之前扩展了左子树，所以现在考虑右子树。此时cp=6，bound(t+1)=cp+rp=15>bestp，因此满足限界条件，扩展右子树，令x[2]=0，生成6号结点。（也就是第2个商品不要了）

（9）扩展6号结点（t=3）。cw+w[3]=6<W，满足约束条件，扩展左分支，令x[3]=1，cw=cw+w[3]=6，cp=cp+v[3]=11，生成7号结点加入**左子树**。（7号结点是第3件商品）。

（10）拓展7号结点（t=4）
cw+w[4]=8<W，满足约束条件，扩展到**左子树**。令x[4]=1，cw=cw+w[4]=8，cp=cp+v[4]=15。（8号结点是第4件商品）

（11）拓展8号结点（t=5）。由于此时t>n，故已经找到了一个当前的最优解，令bestp=cp（值为15），8号结点成为死结点。返回到上一结点。

（12）拓展7号结点（t=4）。考察bound(t+1)=cp+rp=11<15，成为死结点。

（13）拓展6号结点（t=3）。bound(t+1)=cp+rp=10<15，成为死结点。

（14）拓展1号结点（t=1），bound(t+1)=12<15，成为死结点。算法结束。


### 代码实现

    double Bound(int i)//计算上界
    {
    	int rp=0;//剩余重量
    	while (i <= n)
    	{
    		rp += v[i];
    		i++;
    	}
    	return rp+cp;
    }
    
    void Backtrack(int t)//t当前在第t层
    {
    	if (t > n)
    	{
    		for (i = 1; i <= n; i++)
    		{
    			bestx[i] = x[i];
    		}
    		bestp = cp;
    		return;
    	}
    	if (cw + w[t] <= W)//还未到重量，可以搜索左子树
    	{
    		x[t] = true;
    		cw += w[t];
    		cp += v[t];
    		Backtrack(t + 1);
    		cw -= w[t];//回溯
    		cp -= v[t];//回溯
    	}
    	//若左子树不满足，然后看右子树，判断限界条件
    	if (Bound(t + 1) > bestp)
    	{
    		x[t] = false;
    		Backtrack(t + 1);
    	}
    }
    void initial_parameter(double W, int n)
    {
    	cw = 0;//初始化当前重量为0
    	cp = 0;//初始化当前价值为0
    	bestp = 0;//初始化当前最好价值为0
    	int sumw = 0;//统计所有物品的总重量
    	int sumv = 0;//统计所有物品价值
    	//这里上面两个参数可以根据具体情况确定为int或者double等
    	for (i = 1; i <= n; i++)
    	{
    		sumw += w[i];
    		sumv += v[i];
    	}
    	if (sumw <= W)
    	{
    		bestp = sumv;
    		cout << "所有物品均放入购物车";
    		cout << "放入购物车的最大价值为" << bestp << "元。" << endl;
    		return;
    	}
    	Backtrack(1);
    	cout << "放入购物车的最大价值为" << bestp << "元。" << endl;
    	cout << "放入购物车的物品序号为：";
    	for (i = 1; i <= n; i++)
    	{
    		if (bestx[i] == true)
    			cout << i << " ";
    	}
    	cout << endl;
    }

### 算法复杂度和改进
1.算法复杂度
（1）时间复杂度：O(1*2<sup>n</sup>+n * 2<sup>n</sup>)=O(n * 2<sup>n</sup>)。
（2）空间复杂度：O(n)。
2.算法优化
实际上，经常我们在计算bound()函数的时候对于rp多算太多了，因为很有可能rp到某一步就超过了购物车的中梁，所以我们可以缩小上界，从而加快剪枝速度，提高搜索效率。
上界函数bound()：当前价值cp+剩余容量可容纳的剩余物品的最大价值brp（为了能装最大价值，所以在计算上界函数的时候可以对商品分割，**但实际的时候不允许**），即修改为

    double bound(int i)
    {
    	//剩余物品为第i~n种物品
    	double cleft=W-cw;//剩余容量
    	while(i<=n && w[i]<cleft)
    	{
    		cleft-=w[i];
    		brp+=v[i];
    		i++
    	}
    	//下面是采用切割的方式装满背包，这里是求上界，
    	//所以可以这样做。实际是不允许的
    	if(i<=n)
    	{
    		brp+=v[i]/w[i]*cleft;
    	}
    	return cp+brp;
    }

为了更好地计算和运用上界函数剪枝，先将物品按照其单位重量价值（价值/重量）从大到小排序，然后按照排序后的顺序考察各个物品。即定义这样一个结构体：

    struct Object
    {
    	int id;//物品序号
    	double ;//单位重量价值
    };
    
    bool cmp(Object a1, Object a2)
    {
    	return a1.d>a2.d;
    }

 然后将 initial_parameter(double W, int n)的if(sumw<=W)这个语段后面加入：

    sort(Q,Q+n,cmp);
    for(i=1;i<=n;i++)
    {
    	a[i]=w[Q[i-1].id];//把排序后的数据传递给辅助数组
    	b[i]=v[Q[i-1].id];
    }
    for(i=1;i<=n;i++)
    {
    	w[i]=a[i];
    	v[i]=b[i];
    }

 然后将

 	for (i = 1; i <= n; i++)
	{
		if (bestx[i] == true)
			cout << i << " ";
	}

修改为

    	for (i = 1; i <= n; i++)
	{
		if (bestx[i] == true)
			cout << Q[i-1].id << " ";
	}

## 最大团

### 问题描述

部落酋长希望组织一支保卫部落的卫队，要在居民中选出最多的居民加入，并保证卫队中任何两个人都不是仇敌。编程计算构建部落护卫队的最佳方案。

### 问题分析

- 完全子图：给定无向图**G**(V,E)，其中V是结点集，E是边集。**G'**=(V',E')。如果结点集V'⊆V，E'⊆E，且**G'***中的任意两个结点都有边相连，则成**G'**是**G**的完全子图。
- **当且仅当**G'不包含在G的更大的完全子图中时，**G**的完全子图**G'** 是 **G**的团，就是说**G'** 是 **G**的极大完全子图。
- 最大团：G的最大团是指G所有团中，含结点数最多的团。

### 算法设计

1. 定义问题的解空间。问题的解空间为 {x<sub>1</sub>,x<sub>2</sub>,...,x<sub>i</sub>,...,x<sub>n</sub>}的所有子集（包括{0,0,0}这种子集），你像这里面就是{0,0,0,0},{0,0,0,1},{0,0,1,0},{0,0,1,1},…{1,1,1,1}。**显约束**为x<sub>i</sub>=0或1。
2. 解空间的组织结构：子集树，深度为*n*。
3. 搜索解空间：
    - 约束条件：假设当前扩展结点位于解空间树的第t层，那么从第1到第t-1层的结点情况都已经确定，接下来是按照扩展结点的左分支进行扩展，此时需要判断是否将第t个结点放到团里，只要第t和结点和前面t-1个结点中**被选中的结点**都有边连接，那么就能放到团里，即x[i]=1，否则不能放到团里，即x[i]=0。
    - 限界条件：根据前t个结点的状态确定当前已经放入团中的结点个数（用cn表示），假想t+1个结点到第n结点全部放入团内，放入的节点个数（fn表示），fn=n-t，则cn+fn是所有从根出发的路径中经过中间结点z的可行解所包含结点个数的上界。若cn+fn>bestn，则需要向子孙结点搜索，否则不需要。所以限界条件为**cn+fn>bestn**。

### 代码实现


    bool isPlace(int t)
    {
    	bool status = true;
    	for (int j = 1; j < t; j++)
    	{
    		if (x[j] && a[t][j] == 0)
    		{
    			status = false;
    			break;
    		}
    	}
    	return status;
    }
    
    //回溯法主体
    void backtrack(int t)
    {
    	//到达叶结点
    	if (t > n)
    	{
    		for (int i = 1; i <= n; i++)
    			bestx[i] = x[i];
    		bestn = cn;
    		return;
    	}
    
    	if (isPlace(t))
    	{
    		x[t] = 1;
    		cn++;
    		backtrack(t + 1);
    		cn--;
    	}
    	if (cn + n - t > bestn)//这里可以进行优化
    	{
    		x[t] = 0;
    		backtrack(t + 1);
    	}
    }

### 算法复杂度分析
1.时间复杂度：O(n* 2<sup>n</sup>)，空间复杂度为O(n)。

## 着色问题

### 问题分析

假设地图共有7个区域，分别是A/B/C/D/E/F/G，对上面顺序进行编号，每个区域用一个结点表示，相邻的区域有连线，那么地图就转化成一个无向连接图。

### 算法设计

1. 定义问题的解空间。图的m着色问题解空间形式为n元组{x<sub>1</sub>,x<sub>2</sub>,...,x<sub>i</sub>,...,x<sub>n</sub>}，每个分量取值为1,2,3,...,m，即问题的解是一个n元向量。由此可得，问题的解空间为{x<sub>1</sub>,x<sub>2</sub>,...,x<sub>i</sub>,...,x<sub>n</sub>}，其中显约束为x<sub>i</sub>=1,2,...,m。
2. 确定解空间的组织结构：一颗满m叉树，树的深度为n。
3. 搜索解空间
    - 约束条件：假设当前扩展结点位于解空间树的第t层，那么从第1到第t-1层的结点情况都已经确定，接下来是按照扩展结点的第一个分支进行扩展，此时需要判断是否将第t个结点着色情况。第t个结点的色号要与前t-1个结点中与其有边相连的结点颜色不同，如果有颜色相同的，则第t个结点不能用这个色号，换下一个色号尝试。
    - 限界条件：无。
    - 搜索过程：扩展结点沿着第一个分支扩展，判断约束条件，满足则进入深一层继续搜索；如果不满足，则扩展生成的结点被剪掉，换下一个色号尝试。如果所有色号都尝试完毕，该结点变成死结点，向上回溯到距离其最近的活结点，继续搜索。搜索到叶子结点时，找到一种着色方案，搜索过程直到全部活结点变成死结点为止。

### 解题过程
地图7个区域，3种颜色。
1. 开始搜索第1层（t=1）。扩展A结点第一个分支，首先判断是否满足约束条件，因为之前还未着色任何结点，所以满足约束条件，扩展该分支，令1号结点着1号色，即x[1]=1，生成B。
2. 拓展B结点（t=2）。扩展第一个分支x[2]=1，首先判断2号结点是否和前面已经确定色号的结点（1号）有边相连且色号相同，不满足约束条件，剪掉该分支，然后沿着x[2]=2扩展，2号结点和前面已经确定色号的结点（1号）有边相连，但色号不同，满足约束条件，扩展该分支，令x[2]=2。
3. 扩展C结点（t=3）。扩展第一个分支x[3]=1，首先判断3号结点是否和前面已经确定色号的结点（1、2号）有边相连且色号相同，不满足约束条件，剪掉该分支；同理剪掉x[3]=2分支。然后沿着x[3]=3扩展，3号结点和前面已经确定色号的结点（1、2号）有边相连，但色号不同，满足约束条件，扩展该分支，令x[3]=3。生成D。
4. 扩展D结点（t=4）。扩展第一个分支x[4]=1，首先判断4号结点是否和前面已经确定色号的结点（1、2、3号）有边相连且色号相同，不满足约束条件（4余1相连），剪掉该分支；然后令x[4]=2，符合条件，生成E。
5. 扩展E结点（t=5）。扩展第一个分支x[5]=1，首先判断4号结点是否和前面已经确定色号的结点（1、2、3号）有边相连且色号相同，确定5与2、3、4相连但色号不同，满足约束条件，扩展该分支，生成F。
6. 扩展F结点（t=6）。扩展第一个分支x[6]=1，同理不满足，剪掉分支；然后沿着x[6]=2扩展，6与5号有边相连但色号不同，故满足约束条件，扩展该分支，令x[6]=2，生成G。
7. 扩展G结点（t=7）。扩展第一个分支x[7]=1，剪掉x[7]=1和x[7]=2的分支，然后令x[7]=3，符合要求，生成H。
8. 扩展H结点（t=8）。t>n，找到一个可行解，输出该可行解{1,2,3,2,1,2,3}，回溯到最近的活结点G。
9. 重新扩展G结点（t=7）。G已经考察完毕，成为死结点，回溯到最近的活结点F。
10. 继续搜索，又找到第二种着色方案，输出可行解{1,3,2,3,1,3,2}。 
11. 继续搜索，又找到4个可行解。

### 代码实现

    //约束条件
    bool isRight(int t)
    {
    	for (int j = 1; j < t; j++)
    	{
    		if (map[t][j])
    		{
    			if (x[j] == x[t])
    				return false;
    		}
    	}
    	return true;
    }
    
    //回溯方法函数
    void Backtrack(int t)
    {
    	if (t > n)
    	{
    		sum++;
    		cout << "第" << sum << "种方案：";
    		for (int i = 1; i <= n; i++)//输出该着色方案
    		{
    			cout << x[i] << " ";
    		}
    		cout << endl;
    	}
    	else {
    		for (int i = 1; i <= m; i++)
    		{
    			x[t] = i;
    			if (isRight(t))
    				Backtrack(t + 1);
    		}
    	}
    }

### 算法复杂度分析
1. 时间复杂度：O(nm<sup>n</sup>)。
2. 空间复杂度：O(n)。

## n皇后问题

### 问题介绍
在n×n的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋规则，皇后可以攻击与之在同一行、同一列、同一斜线上的棋子。现在在n*n的棋盘上放置n个皇后，使其不受攻击。

### 问题分析
    
 求解策略：
 以行为主导：
 - 在第1行第1列放置第一个皇后。
 - 在第2行放置第2个皇后。第2个皇后的位置不能和前面的皇后同列、同斜线，不用再判断同行了，因为每行我们本来就只放一个。
 - 在第3行放置第3个皇后。第3个皇后的位置不能和前面的皇后同列、同斜线。
 - ……
 - 在第t行放置第t个皇后。第t个皇后的位置不能和前面的皇后同列、同斜线。
 - ……
 - 在第n行放置第n个皇后。第n个皇后的位置不能和前面的皇后同列、同斜线。

### 算法设计

（1）定义问题的解空间。n皇后问题解的形式为n元组：{x<sub>1</sub>,x<sub>2</sub>,...,x<sub>i</sub>,...,x<sub>n</sub>}，分量x<sub>i</sub>表示第i个皇后放置在第i行第x<sub>i</sub>列，x<sub>i</sub>取值为1,2,3,...,n。显约束为不同行。

（2）解空间的组织结构：一颗m(m=n)叉树，树深度为n。

（3）搜索解空间。
约束条件：在第t行放置第t个皇后时，第t个皇后的位置不能和前t-1个皇后同列、同斜线。第i个皇后和第j个皇后不同列，即x<sub>i</sub>!=x<sub>j</sub>。
限界条件：不需要设置。
搜索过程：
从根开始，以DFS的方式进行搜索。根节点是活结点，并且是当前的扩展结点。在搜索过程中，当前的扩展结点沿纵深方向移向一个新结点，判断该新结点是否满足隐约束。如果满足，则该新结点成为活结点，并且成为当前的扩展结点，继续深一层的搜索；如果不满足，则换到该新结点的兄弟结点继续搜索；如果新结点没有兄弟结点，或其兄弟结点已全部搜索完毕，则扩展结点成为死结点，搜索回溯到其父结点处继续进行。搜索过程直到找到问题的根结点变成死结点为止。

### 代码实现

    bool isPlace(int t)
    {
    	bool place = true;
    	for (int j = 1; j < t; j++)
    	{
    		if (x[t] == x[j] || t - j == fabs(x[t] - x[j]))//判断列、对角线是否冲突
    		{
    			place = false;
    			break;
    		}
    	}
    	return place;
    }
    
    void backtrack(int t)
    {
    	if (t > n)
    	{
    		countn++;
    		for (int i = 1; i <= n; i++)
    		{
    			cout << x[i] << " ";
    		}
    		cout << endl;
    		cout << "---------" << endl;
    	}
    	else
    	{//分别判断n个分支，特别注意i不要定义为全局变量，否则递归调用有问题
    		for (int i = 1; i <= n; i++)
    		{
    			x[t] = i;
    			if (isPlace(t))
    				backtrack(t + 1);
    			//上面说的是不冲突就进行下一行搜索
    		}
    	}
    }

### 算法复杂度分析
1. 时间复杂度：O(n<sup>n+1</sup>）。
2. 空间复杂度：O(n)。
